# **Summer Framework - 配置管理模块 (F4) 详细设计说明书 (DDS)**

**版本历史**

| 版本 | 日期       | 作者      | 变更说明                         |
| ---- | ---------- | --------- | -------------------------------- |
| 1.0  | 2025-05-03 | FaustoFan | 基于 ODD 和需求创建初稿          |
| 1.1  | YYYY-MM-DD | (待定)    | (根据详细设计评审和开发迭代更新) |

---

## 1. 引言

### 1.1 目的

本文档旨在详细说明 Summer Framework 配置管理模块 (F4) 的内部设计和实现策略。目标是设计一个支持分层加载、多格式、类型安全访问，并能与 IOC 容器紧密集成以实现配置注入的系统。

### 1.2 范围

本 DDS 覆盖配置源的加载机制、`config-rs` 库的封装、核心服务 (`ConfigService`) 的设计、与 IOC 容器的集成方式（`@Value` 和 `@ConfigurationProperties` 注解的实现），以及错误处理策略。热加载功能作为可选考虑项进行初步设计探讨。

### 1.3 与 ODD 的关系

本文档是对 ODD 中配置管理模块高层设计的具体化和细化，提供了更深入的实现细节、数据结构和算法描述。

### 1.4 参考文献

- Summer Framework - 需求规格说明书 (SRS) v1.0
- Summer Framework - 概要设计说明书 (ODD) v1.0
- [`config` crate (config-rs) 文档](https://docs.rs/config/)
- [`serde` crate 文档](https://serde.rs/)
- Rust 过程宏 (Proc-Macro) 相关文档

### 1.5 术语

遵循 SRS 和 ODD 术语，并强调：

- **配置源 (Configuration Source):** 提供配置数据的地方（如文件、环境变量）。
- **分层加载 (Layered Loading):** 按特定优先级顺序加载多个配置源，后加载的源可以覆盖先加载的源中的同名配置项。
- **Profile (环境):** 用于区分不同部署环境（如 `dev`, `prod`, `test`）的标识符，影响加载哪些配置文件。
- **`ConfigService`:** 框架内部提供统一配置访问的核心服务组件。
- **`@Value`:** 用于将单个配置项注入到 Bean 字段的注解。
- **`@ConfigurationProperties`:** 用于将配置项的一个子树绑定到结构体 Bean 的注解。

---

## 2. 系统概述

配置管理模块是 Summer 框架的基础设施之一。它负责在应用程序启动时，按照预定义的规则从不同的配置源（主要是 YAML/JSON 文件和环境变量）加载配置信息。核心实现将基于成熟的 `config-rs` 库，并封装在一个名为 `ConfigService` 的 IOC Bean 中。该服务提供类型安全的 API (`get<T>()`) 供框架其他部分和用户代码访问配置项。更重要的是，本模块通过与 IOC 容器和过程宏（`summer-macros`）的协作，支持 `@Value` 和 `@ConfigurationProperties` 注解，实现声明式的配置注入，极大简化用户代码。

---

## 3. 详细设计

### 3.1 核心架构

配置模块的核心架构包含以下部分：

1. **加载器 (Loader):** 负责根据 Profile 确定文件路径，并按顺序使用 `config-rs` 构建器 (`ConfigBuilder`) 添加配置源。
2. **配置实例 (`config::Config`):** 由 `config-rs` 生成，持有合并后的最终配置数据。
3. **`ConfigService`:** 一个单例 IOC Bean，持有配置实例 (`Arc<config::Config>`)，并提供公共访问接口。
4. **过程宏 (`@Value`, `@ConfigurationProperties`):** 在编译时处理，生成代码以在 Bean 初始化时从 `ConfigService` 获取配置并注入到目标字段或结构体。

```mermaid
flowchart TD
    subgraph Application_Startup
        DetermineProfile["确定 Profile (Env Var/CLI)"]
        Loader["配置加载器"]
        BuildConfig["config_Config_builder()"]
        ConfigFileDefault["加载 application.yaml/.json"]
        ConfigFileProfile["加载 application-{profile}.yaml/.json"]
        EnvVars["加载环境变量 (SUMMER_*)"]
        BuildInstance["builder.build() -> config::Config"]
        CreateService["创建 ConfigService 实例"]
        RegisterBean["注册 ConfigService 为 IOC Bean"]
    end

    subgraph IOC_Container
        IoC["IOC 容器"]
        ConfigServiceBean["ConfigService Bean (持有 Arc<config::Config>)"]
    end

    subgraph User_Code_Framework_Components
        UserBean["用户 Bean 或其他框架组件"]
        ValueMacro["@Value 处理 (编译时)"]
        ConfigPropsMacro["@ConfigurationProperties 处理 (编译时)"]
        GetValueCall["运行时: 调用 configService.get<T>()"]
    end

    DetermineProfile --> Loader
    Loader --> BuildConfig
    BuildConfig --> ConfigFileDefault
    ConfigFileDefault --> ConfigFileProfile
    ConfigFileProfile --> EnvVars
    EnvVars --> BuildInstance
    BuildInstance --> CreateService
    CreateService --> ConfigServiceBean
    RegisterBean -- "注册" --> IoC

    ValueMacro -- "生成代码" --> UserBean
    ConfigPropsMacro -- "生成代码/影响Bean创建" --> UserBean
    UserBean -- "初始化时依赖" --> IoC
    IoC -- "提供实例" --> UserBean
    UserBean -- "初始化代码调用" --> GetValueCall
    GetValueCall -- "访问" --> ConfigServiceBean


```

### 3.2 配置加载流程

配置加载发生在应用程序启动的早期阶段，通常在 IOC 容器初始化 Bean 之前完成。

#### 3.2.1 Profile (环境) 确定

1. **优先级:**
   - 首先尝试从**命令行参数**读取 Profile (如果集成了 CLI 解析，如 `clap`)。例如 `--summer.profile=prod`。
   - 其次尝试从**环境变量**读取 Profile。定义一个标准的环境变量名，例如 `SUMMER_PROFILE` (e.g., `SUMMER_PROFILE=dev`)。
   - 如果都未指定，可以设定一个**默认 Profile**，例如 `default`，或者不使用 Profile（只加载 `application.yaml`）。
2. **实现:** 这部分逻辑需要在框架启动引导代码中实现，并将确定的 Profile 名称传递给配置加载器。

#### 3.2.2 配置源加载顺序

必须严格按照以下优先级顺序加载，后加载的会覆盖先加载的同名配置：

1. **默认配置文件:** `application.yaml` 或 `application.json` (路径相对于工作目录或可执行文件目录，需要确定查找策略)。`required(false)` 允许文件不存在。
2. **Profile 特定配置文件:** `application-{profile}.yaml` 或 `application-{profile}.json`。`required(false)`.
3. **环境变量:** 使用 `config::Environment`。

#### 3.2.3 加载实现 (使用 `config-rs`)

```rust
use config::{Config, ConfigError, Environment, File, FileFormat};
use std::env;

// Simplified example within a hypothetical init function
fn load_config(profile: Option<String>) -> Result<Config, ConfigError> {
    let mut builder = Config::builder();

    // 1. Load default config file (try YAML then JSON)
    builder = builder.add_source(
        File::new("config/application", FileFormat::Yaml).required(false)
    );
    builder = builder.add_source(
        File::new("config/application", FileFormat::Json).required(false)
    ); // config-rs handles format detection better now, might simplify

    // 2. Load profile-specific config file if profile is set
    if let Some(prof) = profile {
        let profile_filename = format!("config/application-{}", prof);
        builder = builder.add_source(
            File::new(&profile_filename, FileFormat::Yaml).required(false)
        );
         builder = builder.add_source(
            File::new(&profile_filename, FileFormat::Json).required(false)
        );
    }

    // 3. Load environment variables
    // Prefix "SUMMER", separator "__" for nested keys (e.g., SUMMER_SERVER__PORT)
    // Case-insensitive keys can be useful: .try_parsing(true)
    builder = builder.add_source(
        Environment::with_prefix("SUMMER")
            .separator("__")
            .try_parsing(true) // Attempt to parse types (e.g., "true" -> bool)
            .list_separator(",") // Support lists like "host1,host2"
    );

    // Optionally load system environment variables without prefix (lower priority)
    // builder = builder.add_source(Environment::default().separator("__"));

    builder.build()
}

// Note: Actual file path searching logic needs to be robust (e.g., check current dir, executable dir)
// Note: Profile determination needs to happen before calling this.
```

### 3.3 `ConfigService` 组件

#### 3.3.1 职责

- 持有最终合并后的 `config::Config` 实例。
- 提供线程安全、类型安全的配置项访问接口。
- 作为 IOC 容器中的单例 Bean 存在。

#### 3.3.2 结构

```rust
use config::{Config, ConfigError};
use serde::Deserialize;
use std::sync::Arc;
// Use tokio::sync::RwLock only if hot-reloading is needed
// use tokio::sync::RwLock;

// Mark this struct with #[component] or similar by summer-ioc
pub struct ConfigService {
    // Use Arc for cheap cloning if ConfigService itself needs to be passed around.
    // If ConfigService is always accessed via Arc<ConfigService> from IOC,
    // inner Arc might be redundant unless Config itself needs shared access outside ConfigService.
    // Let's assume ConfigService is Arc'd by IOC, so inner config can be plain.
    // If hot-reloading needed: config: RwLock<Config>,
    config: Config,
    active_profile: Option<String>, // Store the profile used for loading
}

impl ConfigService {
    // Private constructor called during initialization
    pub(crate) fn new(config: Config, active_profile: Option<String>) -> Self {
        ConfigService { config, active_profile }
    }

    // ... methods ...
}

// Need to ensure ConfigService is Send + Sync if used across threads.
// config::Config itself should be Send + Sync.
```

#### 3.3.3 核心方法

```rust
use serde::de::DeserializeOwned; // More precise bound

impl ConfigService {
    /// Retrieves a configuration value and deserializes it into the requested type `T`.
    ///
    /// # Arguments
    /// * `key` - The configuration key (e.g., "server.port", "database.url").
    ///
    /// # Errors
    /// Returns `ConfigError` if the key is not found or cannot be deserialized into `T`.
    pub fn get<T: DeserializeOwned>(&self, key: &str) -> Result<T, ConfigError> {
        // If hot-reloading: let cfg_guard = self.config.read().await; cfg_guard.get(key)
        self.config.get(key)
    }

    /// Retrieves a configuration value, returning a default if not found or if deserialization fails.
    pub fn get_or_default<T: DeserializeOwned + Default>(&self, key: &str) -> T {
        self.get(key).unwrap_or_default()
    }

    /// Retrieves a configuration value, returning the provided default value if not found
    /// or if deserialization fails.
    pub fn get_or<T: DeserializeOwned>(&self, key: &str, default: T) -> T {
        self.get(key).unwrap_or(default)
    }

     /// Retrieves a configuration value, returning None if not found
     /// or if deserialization fails.
    pub fn get_opt<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>, ConfigError> {
       self.config.get(key) // config-rs get already handles optionality this way
       // Or more explicitly:
       // match self.config.get(key) {
       //     Ok(v) => Ok(Some(v)),
       //     Err(e) if e.kind() == config::ErrorKind::NotFound => Ok(None),
       //     Err(e) => Err(e),
       // }
    }

    /// Gets the active profile used during configuration loading, if any.
    pub fn get_active_profile(&self) -> Option<&str> {
        self.active_profile.as_deref()
    }
}
```

#### 3.3.4 IOC 集成

- `ConfigService` 实例在应用程序启动时，由引导代码（或特定的 `@Configuration` 类）创建，并使用配置加载流程的结果进行初始化。
- 该实例随后被注册为一个**单例 Bean** 到 `summer-ioc` 容器中。
- 其他需要访问配置的组件（包括由 `@Value` 和 `@ConfigurationProperties` 宏生成的代码）将通过 IOC 注入或查找 `Arc<ConfigService>` 实例。

### 3.4 与 IOC 的集成：配置注入

配置注入主要通过 `summer-macros` crate 实现的过程宏完成。

#### 3.4.1 `@Value` 注解实现

- **语法:** `#[value("${config.key:defaultValue}")] field: FieldType`
- **宏解析 (`summer-macros`):**

  1. 应用于结构体字段。
  2. 解析属性字符串 `"${...}"`。
  3. 提取 `config.key`。
  4. 提取可选的 `:defaultValue` 字符串。
  5. 获取字段的类型 `FieldType`。
- **代码生成:**

  - 这通常与 IOC 的字段注入或初始化逻辑结合。假设 IOC 有一个机制能在 Bean 实例化后（但在 `@PostConstruct` 之前，或者就是 `@PostConstruct` 的一部分）填充字段。
  - 生成的代码大致如下（概念性）：

    ```rust
    // Inside the bean's initialization logic generated by IOC/macros
    {
        // 1. Get ConfigService instance from IOC context
        let config_service = context.get_bean::<::summer_config::ConfigService>().expect("ConfigService not found"); // Or handle error

        // 2. Define key and optional default
        const CONFIG_KEY: &str = "config.key";
        const DEFAULT_VALUE_STR: Option<&str> = Some("defaultValue"); // Or None

        // 3. Try to get the value
        let value_result = config_service.get::<FieldType>(CONFIG_KEY);

        // 4. Assign or use default
        let final_value = match value_result {
            Ok(v) => v,
            Err(_e) => { // Handle specific errors? e.g., NotFound vs Deserialize
                match DEFAULT_VALUE_STR {
                    Some(default_str) => {
                        // Attempt to parse default_str into FieldType
                        // This requires FieldType to implement FromStr or similar,
                        // or handle common types (String, numbers, bool) explicitly.
                        // Use serde_plain or similar if needed.
                        default_str.parse::<FieldType>().expect(&format!(
                            "Failed to parse default value '{}' for key '{}' into type {}",
                            default_str, CONFIG_KEY, stringify!(FieldType)
                        )) // Panic on failure (Spring-like)
                    }
                    None => {
                        panic!("Configuration key '{}' not found and no default value provided.", CONFIG_KEY); // Panic if required
                    }
                }
            }
        };
        // Assign final_value to the target field (e.g., self.field = final_value)
        target_struct_instance.field_name = final_value;
    }
    ```
  - **关键挑战:** 实现默认值的通用解析（需要知道 `FieldType` 并尝试 `FromStr` 或类似转换，或者使用 `serde` 反序列化默认值字符串）。错误处理策略（panic vs. Result）。

#### 3.4.2 `@ConfigurationProperties` 注解实现

- **语法:** `#[configuration_properties(prefix = "database")] #[derive(Deserialize)] struct DatabaseConfig { ... }`
- **宏解析 (`summer-macros`):**
  1. 应用于 `struct`。
  2. 读取 `prefix` 参数。
  3. (可选) 确认 `struct` 派生了 `serde::Deserialize`。
- **实现方式 1 (作为 Bean Definition):**
  - `@configuration_properties` 宏本身充当一个特殊的 `@Component`。
  - IOC 容器在扫描时识别到它。
  - 在实例化该 Bean 时，IOC 调用生成的代码：
    ```rust
    // Inside IOC's bean creation logic for DatabaseConfig
    {
        let config_service = context.get_bean::<::summer_config::ConfigService>().unwrap();
        const PREFIX: &str = "database";
        // Use config::Config::get with the prefix to deserialize the whole struct
        let config_bean: DatabaseConfig = config_service.get(PREFIX)
            .expect(&format!("Failed to bind configuration properties with prefix '{}' to {}", PREFIX, stringify!(DatabaseConfig)));
        // Return config_bean as the created Bean instance
        config_bean
    }
    ```
- **实现方式 2 (配合 `@Component`):**
  - 用户需要同时标记 `@Component` 和 `@configuration_properties`。
  - `@configuration_properties` 宏可能修改由 `@Component` 生成的初始化代码，在其中加入从 `ConfigService` 反序列化并填充自身字段的逻辑。
- **决策:** 方式 1 更简洁，将配置绑定和 Bean 定义合二为一，更像 Spring Boot 的 `@ConfigurationPropertiesScan` + `@ConfigurationProperties` 行为。

### 3.5 配置格式支持

- 依赖 `config-rs` 库，通过启用其 `yaml` 和 `json` feature 来支持这两种格式。
- 文件加载逻辑应能处理两种扩展名 (`.yaml`/`.yml` 和 `.json`)。

### 3.6 热加载 (可选/未来)

- **触发:** 需要集成文件系统监听库 (e.g., `notify-rs`) 来监控配置文件（`application.yaml`, `application-{profile}.yaml`）。
- **重新加载:** 监听到变化后，重新执行 [配置加载流程](#32-配置加载流程)，得到新的 `config::Config` 实例。
- **原子更新:** 使用 `tokio::sync::RwLock` 包装 `ConfigService` 内部的 `config::Config` 实例。获取写锁，然后替换掉旧的实例。
  ```rust
   // Inside ConfigService, assuming config is RwLock<Config>
   async fn reload_config(&self, new_config: Config) {
       let mut config_guard = self.config.write().await;
       *config_guard = new_config;
       // Drop the guard quickly
   }
  ```
- **变更通知 (挑战):** 如何通知使用了 `@Value` 或 `@ConfigurationProperties` 的 Bean 配置已更新？
  - **方案 A (简单轮询):** Bean 自己定期或在每次使用配置时重新从 `ConfigService` 获取（性能差）。
  - **方案 B (回调/监听器):** `ConfigService` 提供注册监听器的机制。Bean 在初始化时注册自己。配置更新后，`ConfigService` 遍历并调用监听器的 `on_config_change` 方法。Bean 负责重新获取配置或重新绑定。这需要设计监听器 trait 和管理注册表。
  - **方案 C (事件总线):** 框架提供一个全局事件总线。`ConfigService` 在更新后发布 `ConfigChangedEvent`。感兴趣的 Bean 订阅此事件。
- **复杂性:** 热加载显著增加了系统的复杂性，尤其是在并发环境下的通知和状态更新。**建议作为 v1.0 之后的功能。**

---

## 4. 数据结构

### 4.1 配置访问结构 (`ConfigService`)

如 [3.3.2 结构](#332-结构) 所述，主要包含 `config::Config` 实例和 `active_profile`。

### 4.2 示例配置映射结构体

用户需要定义自己的结构体来映射配置的特定部分，并使用 `#[derive(Deserialize)]`。

```rust
use serde::Deserialize;

// Example for application.yaml:
// server:
//   port: 8080
//   host: "0.0.0.0"
// database:
//   url: "postgres://user:pass@host/db"
//   pool_size: 10

#[derive(Deserialize, Debug)]
pub struct ServerConfig {
    #[serde(default = "default_port")]
    port: u16,
    #[serde(default = "default_host")]
    host: String,
}
fn default_port() -> u16 { 8080 }
fn default_host() -> String { "127.0.0.1".to_string() }

#[derive(Deserialize, Debug)]
pub struct DatabaseConfig {
    url: String,
    #[serde(default = "default_pool_size")]
    pool_size: usize,
}
fn default_pool_size() -> usize { 5 }

// Root configuration structure used internally or for full config loading
#[derive(Deserialize, Debug)]
pub struct AppConfig {
    #[serde(default)]
    server: ServerConfig,
    database: Option<DatabaseConfig>, // Make parts optional
    logging: Option<serde_yaml::Value>, // Or a specific LoggingConfig struct
    // ... other sections
}

// Example usage with @ConfigurationProperties
#[derive(Deserialize, Debug, Clone)] // Clone might be useful if registered as bean
#[configuration_properties(prefix = "server")]
pub struct ServerProperties {
     #[serde(default = "default_port")]
    port: u16,
    #[serde(default = "default_host")]
    host: String,
}

```

---

## 5. 接口设计

### 5.1 公共接口 (`ConfigService`)

- `fn get<T: DeserializeOwned>(&self, key: &str) -> Result<T, ConfigError>`
- `fn get_or_default<T: DeserializeOwned + Default>(&self, key: &str) -> T`
- `fn get_or<T: DeserializeOwned>(&self, key: &str, default: T) -> T`
- `fn get_opt<T: DeserializeOwned>(&self, key: &str) -> Result<Option<T>, ConfigError>`
- `fn get_active_profile(&self) -> Option<&str>`

### 5.2 注解接口 (通过 Proc-Macros)

- `#[value("${key:defaultValue}")]`
- `#[configuration_properties(prefix = "prefix.path")]`

---

## 6. 错误处理

- **加载阶段:**
  - 文件 I/O 错误（权限、路径问题）：应记录错误并可能阻止启动，或继续（如果文件 `required(false)`）。返回 `ConfigError`。
  - 文件解析错误（YAML/JSON 格式无效）：阻止启动，返回 `ConfigError`。
  - 环境变量解析错误 (`try_parsing`): `config-rs` 会记录警告，但通常不会阻止加载。
- **初始化阶段:**
  - `ConfigService` 注册失败（IOC 问题）：框架级错误。
  - `@Value` / `@ConfigurationProperties` 注入失败：
    - Key 未找到且无默认值：**Panic**（默认策略，类似 Spring）。
    - 默认值解析失败：**Panic**。
    - 类型反序列化失败 (`get<T>`): 返回 `ConfigError`，注入时应 **Panic**。
- **运行时访问:**
  - `ConfigService::get()` 返回 `Result<T, ConfigError>`。用户代码需要处理 `Err`（通常是 `ErrorKind::NotFound` 或 `ErrorKind::Deserialize`）。
  - `get_or_default`, `get_or` 隐藏了错误，直接返回默认值。

---

## 7. 设计原理与权衡

- **基于 `config-rs`:** 利用现有成熟库，避免重复造轮子，获得其丰富的功能（多格式、分层、环境变量）。缺点是受限于该库的特性和 API。
- **类 Spring Boot 注入注解:** 主要为了提升熟悉 Java/Spring 开发者的易用性。代价是需要复杂的宏实现。
- **编译时 vs 运行时注入:** 编译时处理 (`@Value` 代码生成) 性能更好，更符合 Rust 静态类型风格，但宏编写复杂。运行时查找配置性能稍差。
- **Panic on Injection Error:** 默认在 `@Value` 或 `@ConfigurationProperties` 注入失败时 Panic，可以快速暴露配置问题，符合“快速失败”原则，但也可能被认为不够健壮。可以考虑提供配置选项来改变此行为（返回 `Result` 或 `Option`），但这会增加 Bean 初始化逻辑的复杂性。
- **热加载复杂性:** 热加载带来的运行时复杂性（线程安全、通知机制）很高，与 Rust 强调编译期保证的理念有所不同。将其列为可选/未来功能是务实的。
- **Profile 确定机制:** 依赖环境变量或命令行参数是标准做法，但框架需要提供明确的文档和优先级说明。

---
